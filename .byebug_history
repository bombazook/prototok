exit
Prototok::Encoders.const_get :Protobuf, false
exit
require 'tempfile'
Prototok::Encoders.const_get :Protobuf, false
exit
Prototok::Encoders.const_get :Protobuf, false
Prototok::Encoders.const_get :Msgpack, false
Prototok::Encoders.const_get :Json, false
exit
described_class.send(:encoder, 'msgpack')
exit
described_class.send(:encoder, 'protobuf')
exit
described_class.send(:encoder, 'protobuf')
Prototok::Encoders.find :prototok
exit
Prototok::Encoders.find :prototok
Prototok::Encoders.find :protot
Prototok::Encoders.find :prototok
exit
described_class.send(:encoder, 'protobuf')
begin
exit
described_class.send(:encoder, 'protobuf') rescue Exception => e
exit
described_class.send(:encoder, 'protobuf') rescue e => Exception
exit
described_class.send(:encoder, 'protobuf') rescue Exception
exit
described_class.send(:encoder, 'protobuf') rescue Exception
described_class.send(:encoder, 'protobuf') rescue Exception => e
described_class.send(:encoder, 'protobuf') rescue Exception => e; puts e
begin; described_class.send(:encoder, 'protobuf'); rescue Exception => e; puts e ;end
exit
begin
begin; described_class.send(:encoder, 'protobuf'); rescue Exception => e; puts e ;end
begin; described_class.send(:encoder, 'protobuf'); rescue e => Exception; puts e ;end
begin; described_class.send(:encoder, 'protobuf'); rescue Exception => e; puts e ;end
begin; described_class.send(:encoder, 'protobuf'); rescue e => Exception; puts e ;end
begin; described_class.send(:encoder, 'protobuf'); rescue e => Exception; ;end
begin; described_class.send(:encoder, 'protobuf'); rescue e => Exception; end
exit
described_class.send :encoder, 'protobuf'
exit
described_class.encode payload, private_key, **options
described_class.encoder 
described_class.send :encoder,options[:encoder]
described_class.encoder options[:encoder]
described_class.encode payload, private_key, **options
described_class
exit
other_public_key
exit
described_class.
described_class
described_class.key(other_private_key)
other_public_key
exit
private_key
remote_public_key
exit
defaulted
exit
defaulted
combinations
combinations.last.first
exit
combinations.last.first
combinations.first.first
combinations.first
combinations
exit
combinations
exit
exti
combinations
exit
combinations
exit
combinations
exit
described_class.encode(*args)
exit
Prototok.send :cipher, op: :mac, version: 1
Prototok.send :cipher, op: :mac
exit
 described_class.send :cipher, op: :mac
 described_class.send :cipher, op: op
version
op
exit
described_class.encode *args
args
*args
described_class
exit
Object.const_get opts.payload_class
opts.payload_class
try_get_existed opts.payload_class
payload_class opts
payload_klass
opts
self
self.options.payload_class
self.class.options.payload_class
payload_klass
payload_class
exit
decoded_token[:exp]
decoded_token['exp']
obj.each_pair{|k,v| puts "#{k} => #{v}"}
exit
Prototok::Token.decode(blob).to_h
exit
Prototok::Token.new.to_h
Prototok::Token.new.methods
Prototok::Token.new.each
Prototok::Token.new.keys
Prototok::Token.new
obj.entries
obj.keys
obj.each{|k,v| puts "#{k} - #{v}"}
obj.each{|k,v|}
exit
self.class.payload_class(**opts)
opts
exit
self.to_h.select{|k,v| !v.nil?}.merge(payload: any)
any
token
exit
self.to_h.select{|k,v| !v.nil?}
self.to_h
Prototok::Token.new(:exp => 1)
Prototok::Token.new(:exp => nil)
Prototok::Token.new self.to_h
Prototok::Token.new()
Prototok::Token.new(self.to_h.merge(payload: any))
Prototok::Token.new self.to_h.merge(payload: any)
Prototok::Toke.new self.to_h.merge(payload: any)
self.to_h.merge payload: any
self.to_h
self
exit
File.exist? File.expand_path path
File.expand_path path
File.exist? path
path
exit
temp.read
temp
temp.rewind
temp.save
temp.read
temp.write input
input
temp
emp
exit
File.read output_file
file.read output_file
output_file
exit
File.dirname "/Users/bombazook/dev/prototok/lib/prototok/encoders/protobuf/token.proto"
exit
File.dirname "/Users/bombazook/dev/prototok/lib/prototok/encoders/protobuf/token.proto"
File.path "/Users/bombazook/dev/prototok/lib/prototok/encoders/protobuf/token.proto"
File.pathname
output_file
path
exit
RbNaCl::Signatures::Ed25519::SigningKey.generate.to_bytes
RbNaCl::Signatures::Ed25519::SigningKey.generate
private_key.nil?
private_key
exit
cipher_args
encoded
exit
args.first.size
args.first
args
exit
args
